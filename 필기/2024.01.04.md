# 2024.01.04

## 배운 내용 복습

### 콘솔 입출력

- 콘솔에서의 기본 입력을 키보드를 통해서 하고, 기본 출력을 모니터를 통해서 한다.

### 출력도구

- System.out.println() : 출력 + 개행

- System.out.print() : 출력

- System.out.printf() : 출력(포맷지원)

- String.format() : 콘솔 이후에는 printf() 대신 format()를 사용한다.

```java
// %d, %s, %f, %c ,%d
int price = 1234567;
System.out.printf("금액 : %,d원", price);
```

### 

### 입력도구

- System.in.read(): 1 문자 입력, 한글 입력 불가능

- BufferedReader : 1 문자 입력, 문장입력 가능(****), 한글 입력 가능 

- Scanner :  1 문자 입력, 문장입력 가능(****), 한글 입력 가능, 모든 자료형으로 입력 가능 

### 

### 형변환

- 값형끼리의 형변환

- 하나의 숫자 타입을 다른 숫자 타입으로 변환한다.

- boolean은 형 변환의 대상이 될 수 없다.

### 

### 암시적 형 변환, Promotion

- 큰형 = 작은형

- 100% 안전

- 값이 온전하게 복사된다.

### 

### 명시적 형 변환, Cast

- 작은형 = 큰형

- 경우에 따라 안전할 수 도 있고, 불안전할 수도 있다.

- 개발자가 신경써서 값은 범위를 늘 사전에 확인 해야한다.

- 잘못하면 오버플로우(Overflow)가 발생해서 값의 손실을 발생할 수 있다.

## 

---

## 연산자, Operator

- 수학 연산자 > 프로그래밍 연산자

- 피연산자를 대상으로 미리 정해진 연산(행동)을 한 후에 연산(행동)의 결과를 반환하는 역할

- 주로 기호를 사용 + 단어도 사용
1. 문장, Statement

2. 표현식, Expression

3. 연산자, Operator

4. 피연산자, Operand

5. 연산자 우선순위

6. 연산자 연산방향

7. 문장, Statement
- 1개 이상의 표현식이 모여서 문장을 만든다.

    ex) int sum = 10 +20;

2. 표현식, Expression
- 문장을 구성하는 최소 단위

    ex) int sum

          10 +20

           sum = 30

           10

           20

3. 연산자, Operator
- +

- =
4. 피연산자, Operand
- + : 10, 20

- = : sum, 30
5. 연산자 우선순위
- 하나의 문장에 속해있는 연산자들 중 누구를 먼저 실행해야 할 지 정해져있는 순서

- 1 + 2 x 3

- 산술 연산자 > 비교연산자 > 논리 연산자 > 대입 연산자
6. 연산자 연산방향
- 하나의 문장에 속해있는 연산자들이 모두 연산자 우선 순위가 동일 할 때 누구를 먼저 실행해야할지 정해져 있는 순서

- 연산자 종류
1. 행동 ( 목적)
   
   a. 산술 연산자
   
   b. 비교 연산자
   
   c. 논리 연산자
   
   d. 대입 연산자
   
   e. 증감 연산자
   
   f. 조건 연산자
   
   g. 비트 연산자

2. 형태 (피연산자 개수)
   
   a. 1항 연산자, 단항 연산자
   
   b. 2항 연산자
   
   c. 3항 연산자

--- 

#### a. 산술 연산자

> +, -, *, /, %(mod, 나머지)
> 
> 이항 연산자
> 
> 피연산자를 숫자형을 가진다. (정수,실수)

**모든 산술 연산자의 결과값의 자료형**

: 두 피연산자의 자료형 중에서 더 크기가 더 큰 자료형으로 반환된다. => 데이터 손실을 최소화하기 위해서

```java
int e = 1000;
byte f = 10;
System.out.println(e+f); //int + byte = int

int g = 1000000000;
int h = 2000000000;

long i =(long)g+h;
System.out.println(i); //int 30억을 표현할 수 없음.
```

---

#### b. 비교연산자

> , >=, <, <=, ==, !=
> 
> 이항 연산자
> 
> 피연산자들의 우위(동등) 비교
> 
> 피연산자는 숫자형을 가진다
> 
> 연산의 결과가 boolean이다. (true,false)

```java
System.out.println("나이 입력:");

BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

String input = reader.readLine();

int age = Integer.parseInt(input); //"25" > 25 바꿈

System.out.println(age >= 18);
System.out.println();
```

하지만 문자열에서는

*** 문자열의 비교는 ==, != 연산자를 무조건 사용하면 안된다.

*** 문자열의 비교는 equals() 메서드를 사용한다.

```java
String s1 = "홍길동";
String s2 = "홍길동";


System.out.println(s1.equals(s2)); //s1 == s2
```

---

#### c. 논리연산자

> &&(and), ||(or), !(not)
> 
> 2항 연산자 (&&, ||)
> 
> 1항 연산자 (!)
> 
> 피연산자의 자료형이 boolean이다.
> 
> 연산의 결과가 boolean이다.
> 
> 피연산자를 정해진 규칙에 따라 연산을 한 후에 값을 반환

- A && B = ?
  
  논리곱(X) T = 1 , F = 0
  
  - T && T = T
  
  - T && F = F
  
  - F && T = F
  
  - F && F = F

- A || B = ?
  
  논리합(+) T = 1 , F = 0
  
  - T || T = T
  
  - T || F = T
  
  - F || T = T
  
  - F || F = F

- !A = ?
  
  !T = F
  
  !F = T

```java
int age = 25;

System.out.println((18 <= age) && (age < 60);
```

---

#### d. 대입 연산자, 할당 연산자

> =
> 
> +=, -=, *=, /=, %= (복합 대입 연산자)
> 
> LValue(변수) = RValue(상수,변수)
> 
> LValue와 RValue의 지료형이 동일해야한다. > 형변환
> 
> 대입 연산자는 모든 연산자들 중 우선 순서가 가장 낮다.
> 
> 대입 연산자는 연산 방향이 오른쪽 > 오니쪽으로 실행된다.

```java
int m1 = 100;
int m2;
int m3;

//m2 = m1;
//m3 = m1;

m3 = m2 = m1; //대입 연산자만 오른쪽부터 실행

System.out.println(m3);
```

```java
int n = 10;


n = n + 1 ;
System.out.println(n);

n += 1;
System.out.println(n);
```

---

#### e. 증감 연산자

> ++(증가), --(감소)
> 
> 1항 연산자
> 
> 피연산자는 숫자형을 가진다.
> 
> 누적 연산을 한다.
> 
> 기존의 값에 1을 더한다. 1을 뺀다.
> 
> ***연산자와 피연산자의 위치를 바꿀 수 있다.
> 
> *** 연산자의 위치에 따라 연산자의 우선 순위가 달라진다.

1. ++n: 전위배치(전치) > 연산자 우선 순위가 가장 높다. (괄호보단 낮음)

2. n++: 후위배치(후치) > 연산자 우선 순위가 가장 낮다. (대입 연산자보다 낮음)

```java
        n = 10;
        int result = 0;

        result = 10 + ++n;

        System.out.println(result); //21


        n = 10;
        result =0; 

        result = 10 + ++n;

        System.out.println(result); //20
```

---

#### f. 조건 연산자

> ? :
> 
> 3항 연산자
> 
> A ? B : C
> 
> A : boolean > 조건으로 사용
> 
> B,C : 상수,변수 > 연산의 결과로 사용
> 
> A가 참이면 B를 반환, 거짓이면 C를 반환



----

### 메서드, Method

- 함수(Function),프로사저(Procedure), 서브 루틴(Sub Routine)...

- 코드의 집합

- 같은 목적을 가진 코드의 집합

- 코드 재사용의 단위(****)



#### 메서드 선언 위치

- 클래스 내부

- 메서드의 순서는 무관



- 메서드 선언
  
  - 메서드 헤더(header), Signature(서명)
  
  - 접근지정자/정적키워드/ 반환타입/ 메서드이름/ 인자리스트
  
  - public static void hello ()
  
  - 몸통(Body), 구현부
  
  - -{코드;}

```java
public static void hello() {
	
		//구현부 > 메서드가 하려는 업무
		System.out.println("안녕하세요");
	}
```

<원하는 위치에 hello();라고 호출해주면 끝>



#### 메서드 인자리스트

- 파라미터(Parameters)

- 인자(Argument)

- 매개변수



---

### 자바 변수 종료

- 선언된 위치, 역할 차이
1. 멤버 변수 , Member Variable
- 클래스 수업



2. 지역 변수, Local Variable
- 여태까지 사용한 변수

- 메서드내에서 선언한 변수

- 변수 스코프(Scope) > 변수의 사용 영역(범위) ***

지역 변수의 생명주기, Life Cycle

- 변수가 언제 태어나서(메모리에 생성) ~ 언제 죽는지 (메모리에 소멸)

- 생성 > 변수 선언문이 실행될 때

- 소멸 > 변수 선언문이 포함된 블럭을 빠져나갈 때





---



### 메서드 오버로딩, Method OverLoading

- 같은 이름의 메서드를 여러개 만드는 기술

- 메서드의 인자 리스트를 다양한 형태로 구성해서, 같은 이름의 메서드를 여러개 만드는 기술



+ println()도 오버로딩 !!! (이해 안가면 다시 공부 하세여)





##### 메서드 오버로딩을 하는 이유?

- 성능 향상 > x

- 개발자에게 도움> o => 메서드 하나의 이름만 알면 되기 떄문에 편리함





























  









## 자바 템플릿 (코드 축약어)  만드는 법

: 자바 설정에 template 검색

![](C:\Users\user\AppData\Roaming\marktext\images\2024-01-04-10-46-33-image.png)

editor 밑에 template 들어감

![](C:\Users\user\AppData\Roaming\marktext\images\2024-01-04-10-46-09-image.png)

이 형식에 맞춰서 추가 하면 끝!
